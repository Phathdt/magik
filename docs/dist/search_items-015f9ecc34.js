searchNodes=[{"doc":"Documentation for Magik.","ref":"Magik.html","title":"Magik","type":"module"},{"doc":"Hello world.Examplesiex&gt; Magik.hello() :world","ref":"Magik.html#hello/0","title":"Magik.hello/0","type":"function"},{"doc":"Contract helps to define a contract for function call, and do validate contract data with:Validate typeValidate requiredValidate in|not_in enumValiate length for string, enumerableValidate numberValidate string against regex patternCustom validation functionWith support nested typeClean not allowed fields @update_user_contract %{ user: [type: User, required: true], attributes: [type: %{ email: [type: :string], status: [type: :string, in: ~w(active in_active)] age: [type: :integer, number: [min: 10, max: 80]], }, required: true] } def update_user(contract) do with {:ok, validated_data} do validated_data.user |&gt; Ecto.Changeset.change(validated_data.attributes) |&gt; Repo.update else {:error, errors} -&gt; IO.inspect(errors) end end NOTES: Contract only validate data, not cast dataSupport validationTypeSupport built-in types;booleaninteger,floatnumber - string or integerstringtuplemaparraylistatomfunctionkeywordstructarray of typeExample:Magik.Contract.validate(%{name: &quot;Bluz&quot;}, %{name: [type: :string]}) Magik.Contract.validate(%{id: 123}, %{name: [type: :integer]}) Magik.Contract.validate(%{id: 123}, %{name: [type: {:array, :integer}]}) Magik.Contract.validate(%{user: %User{}}, %{user: [type: User]}) Magik.Contract.validate(%{user: %User{}}, %{user: [type: {:array: User}]})RequiredMagik.Contract.validate(%{name: &quot;Bluz&quot;}, %{name: [type: :string, required: true]})Allow nilMagik.Contract.validate( %{name: &quot;Bluz&quot;, email: nil}, %{ name: [type: :string], email: [type: string, allow_nil: false] })Inclusion/ExclusionMagik.Contract.validate( %{status: &quot;active&quot;}, %{status: [type: :string, in: ~w(active in_active)]} ) Magik.Contract.validate( %{status: &quot;active&quot;}, %{status: [type: :string, not_in: ~w(banned locked)]} )FormatValidate string against regex patternMagik.Contract.validate( %{email: &quot;Bluzblu@gm.com&quot;}, %{name: [type: :string, format: ~r/.+?@.+.com/] })NumberValidate number valueMagik.Contract.validate( %{age: 200}, %{age: [type: :integer, number[greater_than: 0, less_than: 100]] })Support conditionsequal_togreater_than_or_equal_to | mingreater_thanless_thanless_than_or_equal_to | maxLengthCheck length of list, map, string, keyword, tuple Supported condtions are the same with Number checkMagik.Contract.validate( %{title: &quot;Hello world&quot;}, %{age: [type: :string, length: [min: 10, max: 100]] })Custom validation functionInvoke given function to validate value. The function signature must befunc(field_name ::(String.t() | atom()), value :: any(), all_params :: map()) :: :ok | {:error, message}Magik.Contract.validate( %{email: &quot;blue@hmail.com&quot;}, %{email: [type: :string, func: &amp;validate_email/3]}) def validate_email(_name, email, _params) do if Regex.match?(~r/[a-z0-9._%+-]+@[a-z0-9.-]+.[a-z]{2,4}$/, email) do :ok else {:error, &quot;not a valid email&quot;} end endNested mapNested map declaration is the same.data = %{name: &quot;Doe John&quot;, address: %{city: &quot;HCM&quot;, street: &quot;NVL&quot;} } schema = %{ name: [type: :string], address: [type: %{ city: [type: :string], street: [type: :string] }] } Magik.Contract.validate(data, schema)Nested listdata = %{name: &quot;Doe John&quot;, address: [%{city: &quot;HCM&quot;, street: &quot;NVL&quot;}] } address = %{ city: [type: :string], street: [type: :string] } schema = %{ name: [type: :string], address: [type: {:array, address}] } Magik.Contract.validate(data, schema)","ref":"Magik.Contract.html","title":"Magik.Contract","type":"module"},{"doc":"Validate data against given schema","ref":"Magik.Contract.html#validate/2","title":"Magik.Contract.validate/2","type":"function"},{"doc":"EctoEnum helps to generate enum type and enum helper function.You can define an enum module manually like thisdefmodule MyEnum do def enum, do: [&quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;] def value1, do: &quot;value1&quot; def value2, do: &quot;value2&quot; def value3, do: &quot;value3&quot; endNow with EctoEnum you can do it with a few lines of codedefmodule MyEnum do use Magik.EctoEnum, [&quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;] endIt still provides same functions with manual implemented moduleUse different name and valueIn some case, you want to use a different name instead of the same with value, you can pass a tuple like thisdefmodule MyEnum do use Magik.EctoEnum, name1: &quot;Value 1&quot;, name2: &quot;value 2&quot; end MyEnum.name1() # =&gt; &quot;Value 1&quot;Use in ecto schemaEctoEnum also defines a Type module that you can used directly in Ecto schemadefmodule Order do schema &quot;orders do field :first_name, :string field :last_name, :string field :status, MyEnum.Type end endEctoEnum automatically validate value and only allow valid valueUse Enum integerYou can specify type of column in database, default is stringdefmodule MyEnum do use Magik.EctoEnum, enum: [name1: 1, name2: 2], type: :integer end","ref":"Magik.EctoEnum.html","title":"Magik.EctoEnum","type":"module"},{"doc":"ExcelView helps to render Excel content for Elixlsx easierUse as a view defmodule TestView do use Magik.ExcelView # render list or stream def render_content(user_list) do fields = [:name, :email, :age, :is_teenager] render_row(user_list, fields) # or render with assigns render_row(user_list, fields, %{message: &quot;hi&quot;}) end # by default raw value of the item is used # here we define custom render for a specific view def render_field(:is_teenager, user) do if user.age &lt; 20, do: &quot;YES&quot;, else: &quot;NO&quot; end endFields Could be a real field in the data or virtual field. If it's virtual field, you have to define a custom render function as described below. A field could be:field_name Ex: :name{field, format} Ex: {:name, bold: true, italic: true}Custom render You can define custom render function for specific fieldrender_field(field_name, struct)render_field(field_name, struct, assigns)Use without viewExcelView can be used without defining a view.def render_excel_data (user_list) do fields = [ :name, {:email, bold: true}, :age, {:is_teenager, &amp;/is_teenager/1} ] Magik.ExcelView.rener_row(user_list, fields) # or with assigns Magik.ExcelView.rener_row(user_list, fields, %{custom: &quot;custom&quot;}) end def is_teenager(user) do if user.age &lt; 20, do: &quot;YES&quot;, else: &quot;NO&quot; endA field could be:field_name Ex: :name{field, format} Ex: {:name, bold: true, italic: true}{field, render_func}{field, render_func, format}Render functions would be acceptedfunc(struct)func(field_name, struct)","ref":"Magik.ExcelView.html","title":"Magik.ExcelView","type":"module"},{"doc":"render cell without view, in this case, field must be a tuple of{field, render_fn, format}{field, render_fn}{field, format}field_namerender cell with a view, view must define render_cell/2 for each field field definition format:{field_name, format}field_name","ref":"Magik.ExcelView.html#render_cell/4","title":"Magik.ExcelView.render_cell/4","type":"function"},{"doc":"","ref":"Magik.ExcelView.html#render_row/4","title":"Magik.ExcelView.render_row/4","type":"function"},{"doc":"Provides functions to format value to string","ref":"Magik.Formatter.html","title":"Magik.Formatter","type":"module"},{"doc":"Format currency value to thousand separated stringParametersnumber: integer numberopts: list of format optionsthousand_separator: thousand separator character. Default is ,currency: currency character. Default is &quot;Ä‘&quot;Exampleiex&gt; Magik.Formatter.format_currency(&quot;1232321&quot;, thousand_separator: &quot;.&quot;, currency: &quot;$&quot;) 1.232.321$","ref":"Magik.Formatter.html#format_currency/2","title":"Magik.Formatter.format_currency/2","type":"function"},{"doc":"Format number to thousand seperated stringParametersnumber: integer numberseparator: thousand separator character. Default is .Exampleiex&gt; Magik.Formatter.format_thousand(&quot;1232321&quot;, &quot;.&quot;) 1.232.321","ref":"Magik.Formatter.html#format_thousand/2","title":"Magik.Formatter.format_thousand/2","type":"function"},{"doc":"Render a struct to a map with given optionsfields: which fields are extract directly from structcustom_fields: which fields are render using custom render_field/2 functionrelationships: a list of {field, view_module} defines which fields are rendered using another viewHere is a sample viewdefmodule MyApp.PostView do use JsonView @fields [:title, :content, :excerpt, :cover] @custom_fields [:like_count] @relationships [author: MyApp.AuthorView] def render(&quot;post.json&quot;, %{post: post}) do # 1st way if `use JsonView` render_json(post, @fields, @custom_fields, @relationships) # 2nd way same as above JsonView.render_json(post, __MODULE__, fields: @fields, custom_fields: @custom_fields, relationships: @relationships ) # 3rd render manual post |&gt; JsonView.render_fields(@fields) |&gt; Map.merge(JsonView.render_custom_fields(post, __MODULE__, @custom_fields)) |&gt; Map.merge(JsonView.render_relationships(post, @relationships)) end def render_field(:like_count, item) do # load like_count from some where end end","ref":"Magik.JsonView.html","title":"Magik.JsonView","type":"module"},{"doc":"Render field with custom render function View module must defines render_field/2 function to render each custom fielduse JsonView def render_field(:is_success, item) do item.state &gt; 3 end render_custom_fields(struct, __MODULE__, [:is_success])","ref":"Magik.JsonView.html#render_custom_fields/3","title":"Magik.JsonView.render_custom_fields/3","type":"function"},{"doc":"","ref":"Magik.JsonView.html#render_fields/2","title":"Magik.JsonView.render_fields/2","type":"function"},{"doc":"","ref":"Magik.JsonView.html#render_json/3","title":"Magik.JsonView.render_json/3","type":"function"},{"doc":"","ref":"Magik.JsonView.html#render_relationship/3","title":"Magik.JsonView.render_relationship/3","type":"function"},{"doc":"Render relationship field for struct. relationships is a list of {field, view} for mapping render. For each field, call function View.render() to render json for relation object.Example relationships:relationships = [comments: CommentView, author: UserView]Result of render_relationships(post, relationships) equal to output of below code%{ comments: CommentView.render_many(comments, CommentView, &quot;comment.json&quot;), autho: UserView.render_one(author, UserView, &quot;user.json&quot;) }","ref":"Magik.JsonView.html#render_relationships/2","title":"Magik.JsonView.render_relationships/2","type":"function"},{"doc":"","ref":"Magik.JsonView.html#render_template/3","title":"Magik.JsonView.render_template/3","type":"function"},{"doc":"This module provides helpers method to call function depend on condition","ref":"Magik.Maybe.html","title":"Magik.Maybe","type":"module"},{"doc":"","ref":"Magik.Maybe.html#error?/1","title":"Magik.Maybe.error?/1","type":"function"},{"doc":"","ref":"Magik.Maybe.html#ok?/1","title":"Magik.Maybe.ok?/1","type":"function"},{"doc":"This function check first argument, if it is tuple of {:ok, data} then invoke the function with data of the tuple. Otherwise return the first argument.Examplechangeset = User.changeset(%User{}, params) Repo.insert(changeset) |&gt; Maybe.pipe(fn user -&gt; # do something with user end)In case you are using with, don't care about this function","ref":"Magik.Maybe.html#pipe/2","title":"Magik.Maybe.pipe/2","type":"function"},{"doc":"This helper is used in pipe, to invoke function if condition is true, otherwise passing data to nex functionExamplea = 10 b = 12 a |&gt; Kernel.*(2) |&gt; Maybe.pipe( b != 0, &amp; &amp;1/b) |&gt; Kernel.+(10)The condition Could be any value:if condition is true then call the function with the first argumentif condition is function/1 then invoke condition function. If return value is true then invoke the function with first argumentother value of condition don't trigger the function and just return the first argument that passed to this functionExample 2 Using function conditiona = 10 a |&gt; Kernel.+(3) |&gt; Maybe.pipe(&amp; &amp;1 &gt; 0, &amp; &amp;1 - 5)","ref":"Magik.Maybe.html#pipe/3","title":"Magik.Maybe.pipe/3","type":"function"},{"doc":"This function is mostly used with with. In some case, you may want to invoke a function if it meets a specific condition without breaking with into 2 block like thisparams = %{} with {:ok, data} &lt;- insert_something(), :ok &lt;- (if params.checked, do: do_something(data), else: :ok), {:ok, another_data} &lt;- send_something(data) do # aha endThis function help to write it shorterparams = %{} with {:ok, data} &lt;- insert_something(), :ok &lt;- Maybe.run(params.checked, &amp;do_something(data)), {:ok, another_data} &lt;- send_something(data) do # aha end","ref":"Magik.Maybe.html#run/2","title":"Magik.Maybe.run/2","type":"function"},{"doc":"Support light paginate the query. does not support counting total item because counting on large table is expensive update: count total if needed","ref":"Magik.Paginator.html","title":"Magik.Paginator","type":"module"},{"doc":"","ref":"Magik.Paginator.html#paginate/3","title":"Magik.Paginator.paginate/3","type":"function"},{"doc":"Params provide some helpers method to work with parameters","ref":"Magik.Params.html","title":"Magik.Params","type":"module"},{"doc":"Cast and validate params with given schema. See Magik.Schema for instruction on how to define a schema And then use it like thisdef index(conn, params) do index_schema = %{ status: [type: :string, required: true], type: [type: :string, in: [&quot;type1&quot;, &quot;type2&quot;, &quot;type3&quot;]], keyword: [type: :string, length: [min: 3, max: 100]], } with {:ok, data} &lt;- Magik.Params.cast(params, index_schema) do # do query data else {:error, errors} -&gt; IO.puts(errors) end end","ref":"Magik.Params.html#cast/2","title":"Magik.Params.cast/2","type":"function"},{"doc":"","ref":"Magik.Params.html#cast_array/3","title":"Magik.Params.cast_array/3","type":"function"},{"doc":"Clean all nil field from params, support nested map and list.Exampleparams = %{&quot;keyword&quot; =&gt; nil, &quot;email&quot; =&gt; nil, &quot;type&quot; =&gt; &quot;customer&quot;} Magik.Params.clean_nil(params) # =&gt; %{&quot;type&quot; =&gt; &quot;customer&quot;} params = %{user_ids: [1, 2, nil]} Magik.Params.clean_nil(params) # =&gt; %{user_ids: [1, 2]}","ref":"Magik.Params.html#clean_nil/1","title":"Magik.Params.clean_nil/1","type":"function"},{"doc":"A plug which do srubbing paramsUse in Routerdefmodule MyApp.Router do ... plug Magik.Params.plug_srub ... endUse in controllerplug Magik.Params.plug_srub when action in [:index, :show] # or specify which field to scrub plug Magik.Params.plug_srub, [&quot;id&quot;, &quot;keyword&quot;] when action in [:index, :show]","ref":"Magik.Params.html#plug_srub/2","title":"Magik.Params.plug_srub/2","type":"function"},{"doc":"Convert all parameter which value is empty string or string with all whitespace to nil. It works with nested map and list too.Exampleparams = %{&quot;keyword&quot; =&gt; &quot; &quot;, &quot;email&quot; =&gt; &quot;&quot;, &quot;type&quot; =&gt; &quot;customer&quot;} Magik.Params.scrub_param(params) # =&gt; %{&quot;keyword&quot; =&gt; nil, &quot;email&quot; =&gt; nil, &quot;type&quot; =&gt; &quot;customer&quot;} params = %{user_ids: [1, 2, &quot;&quot;, &quot; &quot;]} Magik.Params.scrub_param(params) # =&gt; %{user_ids: [1, 2, nil, nil]}","ref":"Magik.Params.html#scrub_param/1","title":"Magik.Params.scrub_param/1","type":"function"},{"doc":"This module provide some helpers functions that common used with RepoHow to useuse Magik.PowerUpRepo in your Repo module and all helper functions are ready for usedefmodule MyApp.Repo do use Ecto.Repo, otp_app: :my_app, adapter: Ecto.Adapters.Postgres use Magik.PowerUpRepo end","ref":"Magik.PowerUpRepo.html","title":"Magik.PowerUpRepo","type":"behaviour"},{"doc":"Find the first entry in the database that match the filtercase Repo.find(Product, brand_id: 1, is_active: true) do {:ok, product} -&gt; IO.puts(product.name) {:error, :not_found} -&gt; IO.puts(&quot;No product found&quot;) end","ref":"Magik.PowerUpRepo.html#c:find/2","title":"Magik.PowerUpRepo.find/2","type":"callback"},{"doc":"Fetch query by pagination paramaExamplequery = from(p in Product, where: p.quantity &gt; 10) {entries, paginator} = Repo.paginate(query, %{page: 2, size: 5})","ref":"Magik.PowerUpRepo.html#c:paginate/3","title":"Magik.PowerUpRepo.paginate/3","type":"callback"},{"doc":"Preload entries return from Repo.paginateExample{entries, paginator} = from(p in Product, where: p.quantity &gt; 10 ) |&gt; Repo.paginate(%{page: 2, size: 5}) |&gt; Repo.preload([:brand, :category])","ref":"Magik.PowerUpRepo.html#c:preload_paginate/2","title":"Magik.PowerUpRepo.preload_paginate/2","type":"callback"},{"doc":"Load query with given size and provide the result as a streamOptionspage_size: number of entry to load per batchExamplefrom(p in Product, where: p.quantity &gt; 10 ) |&gt; Repo.stream_query(20) |&gt; Stream.map( &amp; &amp;1.name) |&gt; Enum.to_list","ref":"Magik.PowerUpRepo.html#c:stream_query/2","title":"Magik.PowerUpRepo.stream_query/2","type":"callback"},{"doc":"This is only a specification to define a schema to use with Magik.Params.cast and Magik.Contract.validateSchema is just a map or keyword list that follow some simple conventions. Map's key is the field name and the value is a keyword list of field specifications.Example%{ name: [type: :string, format: ~r/\d{4}/], age: [type: :integer, number: [min: 15, max: 50]]. skill: [type: {:array, :string}, length: [min: 1, max: 10]] }This schema define a map with a field name which type is stringI. Field typeBuilt-in typesA type could be any of built-in supported types:booleanstring | binaryintegerfloatnumber (integer or float)datetimedatetime | utc_datetime: date time with time zonenaive_datetime: date time without time zonemapkeyword{array, type} array of built-in type, all item must be the same typeOther types Custom type may be supported depends on module.Nested types Nested types could be a another schema or list of schema%{ user: [type: %{ name: [type: :string] }] }Or list of schema%{ users: [type: {:array, %{ name: [type: :string] }} ] }II. Field casting and default valueThese specifications is used for casting data with Magik.Params.cast1. Default valueIs used when the given field is missing or nil.Default could be a value%{ status: [type: :string, default: &quot;active&quot;] }Or a function/0, this function will be invoke each time data is casted%{ published_at: [type: :datetime, default: &amp;DateTime.utc_now/0] }2. Custom cast functionYou can provide a function to cast field value instead of using default casting function by using cast_func: &lt;function/1&gt;%{ published_at: [type: :datetime, cast_func: &amp;DateTime.from_iso8601/1] }III. Field validationThese validation are supported by Magik.Validator1. Type validationType specification above could be used for validating or casting data.2. Numeric validationSupport validating number value. These are list of supported validations:equal_togreater_than_or_equal_to | mingreater_thanless_thanless_than_or_equal_to | max Define validation: number: [&lt;name&gt;: &lt;value&gt;, ...]Example%{ age: [type: :integer, number: [min: 1, max: 100]] }3. Length validationValidate length of supported types include string, array, map, tuple, keyword. Length condions are the same with Numeric validationDefine validation: length: [&lt;name&gt;: &lt;value&gt;, ...]Example%{ skills: [type: {:array, :string}, length: [min: 0, max: 5]] }4. Format validationCheck if a string match a given pattern.Define validation: format: &lt;Regex&gt;Example%{ year: [type: :string, format: ~r/year: \d{4}/] }5. Inclusion and exclusion validationCheck if value is included or not included in given enumerable (array, map, or keyword)Define validation: in: &lt;enumerable&gt; or not_in: &lt;enumerable&gt;Example%{ status: [type: :string, in: [&quot;active&quot;, &quot;inactive&quot;]], selected_option: [type: :integer, not_in: [2,3]] }6. Custom validation functionYou can provide a function to validate the value.Define validation: func: &lt;function&gt;Function must be follow this signature@spec func(value::any()) :: :ok | {:error, message::String.t()}","ref":"Magik.Schema.html","title":"Magik.Schema","type":"module"},{"doc":"This module provide some helper functions that help to send message to a telegram conversationConfigconfig :magik, :telegram_noti, bot_token: &quot;your bot token&quot;. conversations: [ default: &quot;default_chat_id&quot;, admin: &quot;other chat id&quot; ], mode: :prod # or :devbot_token: your Telegram bot tokentconversations: keyword list of name and chat_id. There must be at least 1 conversation which is :default. default is used if you don't specify conversation name in the function call.Then you are ready to send message to your Telegram conversation","ref":"Magik.TelegramNoti.html","title":"Magik.TelegramNoti","type":"module"},{"doc":"Format and send error message to a Telegam conversation with data from a connection. This helper is used to send error from your phoenix router or controller.From routerdefmodule MyApp.Router do use MyAppWeb, :router use Plug.ErrorHandler ... def handle_errors(conn, error) do if conn.status &gt;= 500 do Magik.TelegramNoti.send_conn_error(:api, conn, error) end .... end endfrom controllerdefmodule MyAppWeb.PageController do ... def index(conn, params)do try do ... catch error -&gt; Magik.TelegramNoti.send_conn_error(:api, conn, %{kind: :error, reason: error, stack: __STACKTRACE__}) # return your error end end end","ref":"Magik.TelegramNoti.html#send_conn_error/3","title":"Magik.TelegramNoti.send_conn_error/3","type":"function"},{"doc":"Format error and send to Telegram conversation.defmodule MyApp.Calculator do ... def divide(a, b)do try do ... catch error -&gt; Magik.TelegramNoti.send_error(:api, &quot;MyApp.Calculator error&quot;, [a,b], %{kind: :error, reason: error, stack: __STACKTRACE__}) # return your error end end end","ref":"Magik.TelegramNoti.html#send_error/4","title":"Magik.TelegramNoti.send_error/4","type":"function"},{"doc":"Send a message to conversationsend_message(:api, &quot;this is a sample message&quot;)","ref":"Magik.TelegramNoti.html#send_message/2","title":"Magik.TelegramNoti.send_message/2","type":"function"},{"doc":"This macro help you to catch exceptions and then send to your Telegram conversation using send_error/4Optionsto: conversation name from your config. Default is :defaultargs: argument list that passed to function, this is sent to telegram chat for dev to debug easier. If not speficied, arguments for current function call are usedlabel: label for this error/function. If not specified, current function name is used.Example... require Magik.TelegramNoti def do_something(args) do Magik.TelegramNoti.watch [to: :admin] do # your logic code here end end ...","ref":"Magik.TelegramNoti.html#watch/2","title":"Magik.TelegramNoti.watch/2","type":"macro"},{"doc":"Cast data to target type. Much code of this module is borrowed from Ecto.Type","ref":"Magik.Type.html","title":"Magik.Type","type":"module"},{"doc":"","ref":"Magik.Type.html#cast/2","title":"Magik.Type.cast/2","type":"function"},{"doc":"","ref":"Magik.Type.html#cast!/2","title":"Magik.Type.cast!/2","type":"function"},{"doc":"","ref":"Magik.Type.html#is_base_type/1","title":"Magik.Type.is_base_type/1","type":"function"},{"doc":"Some helpers function to do validate dataValidate typevalidate inclusion/exclusionvalidate length for string and enumerable typesvalidate numbervalidate string format/patternvalidate custom functionvalidate allow_nil or notEach of these validations can be used separatedlyiex(2)&gt; Magik.Validator.validate_type(10, :integer) :ok iex(3)&gt; Magik.Validator.validate_type(10, :string) {:error, &quot;is not a string&quot;} iex(3)&gt; Magik.Validator.validate_number(9, [min: 10, max: 20]) {:error, &quot;must be greater than or equal to 10&quot;}Or you can combine multiple condition at oneiex(12)&gt; Magik.Validator.validate(10, type: :integer, number: [min: 10, max: 20]) :ok iex(13)&gt; Magik.Validator.validate(&quot;email@g.c&quot;, type: :string, format: ~r/.+@.+.[a-z]{2,10}/) {:error, &quot;format not matched&quot;}","ref":"Magik.Validator.html","title":"Magik.Validator","type":"module"},{"doc":"Validate value against list of validations.iex(13)&gt; Magik.Validator.validate(&quot;email@g.c&quot;, type: :string, format: ~r/.+@.+.[a-z]{2,10}/) {:error, &quot;format not matched&quot;}All supported validations:type: validate datatypeformat: check if binary value matched given regexnumber: validate number valuelength: validate length of supported types. See validate_length/2 for more details.in: validate inclusionnot_in: validate exclusionfunc: custom validation function follows spec func(any()):: :ok | {:error, message::String.t()}","ref":"Magik.Validator.html#validate/2","title":"Magik.Validator.validate/2","type":"function"},{"doc":"Validate embed types","ref":"Magik.Validator.html#validate_embed/2","title":"Magik.Validator.validate_embed/2","type":"function"},{"doc":"Check if value is not included in the given enumerable. Similar to validate_inclusion/2","ref":"Magik.Validator.html#validate_exclusion/2","title":"Magik.Validator.validate_exclusion/2","type":"function"},{"doc":"Checks whether a string match the given regex.iex(11)&gt; Magik.Validator.validate_format(&quot;year: 2001&quot;, ~r/year: \d{4}/) :ok iex(12)&gt; Magik.Validator.validate_format(&quot;hello&quot;, ~r/\d+/) {:error, &quot;does not match format&quot;}","ref":"Magik.Validator.html#validate_format/2","title":"Magik.Validator.validate_format/2","type":"function"},{"doc":"Check if value is included in the given enumerable.iex(21)&gt; Magik.Validator.validate_inclusion(1, [1, 2]) :ok iex(22)&gt; Magik.Validator.validate_inclusion(1, {1, 2}) {:error, &quot;given condition does not implement protocol Enumerable&quot;} iex(23)&gt; Magik.Validator.validate_inclusion(1, %{a: 1, b: 2}) {:error, &quot;not be in the inclusion list&quot;} iex(24)&gt; Magik.Validator.validate_inclusion({:a, 1}, %{a: 1, b: 2}) :ok","ref":"Magik.Validator.html#validate_inclusion/2","title":"Magik.Validator.validate_inclusion/2","type":"function"},{"doc":"Check if length of value match given conditions. Length condions are the same with validate_number/2iex(15)&gt; Magik.Validator.validate_length([1], min: 2) {:error, &quot;length must be greater than or equal to 2&quot;} iex(16)&gt; Magik.Validator.validate_length(&quot;hello&quot;, equal_to: 5) :okSupported typeslistmaptuplekeywordstring","ref":"Magik.Validator.html#validate_length/2","title":"Magik.Validator.validate_length/2","type":"function"},{"doc":"Validate number valueiex(3)&gt; Magik.Validator.validate_number(12, min: 10, max: 12) :ok iex(4)&gt; Magik.Validator.validate_number(12, min: 15) {:error, &quot;must be greater than or equal to 15&quot;}Support conditionsequal_togreater_than_or_equal_to | mingreater_thanless_thanless_than_or_equal_to | max validate_number(x, [min: 10, max: 20])","ref":"Magik.Validator.html#validate_number/2","title":"Magik.Validator.validate_number/2","type":"function"},{"doc":"Validate data types.iex(1)&gt; Magik.Validator.validate_type(&quot;a string&quot;, :string) :ok iex(2)&gt; Magik.Validator.validate_type(&quot;a string&quot;, :number) {:error, &quot;is not a number&quot;}Support built-in types:booleanintegerfloatnumber (integer or float)string | binarytuplemaparrayatomfunctionkeywordIt can also check extend typesstruct Ex: User{:array, type} : array of type","ref":"Magik.Validator.html#validate_type/2","title":"Magik.Validator.validate_type/2","type":"function"},{"doc":"","ref":"Magik.Validator.html#t:error/0","title":"Magik.Validator.error/0","type":"type"},{"doc":"","ref":"Magik.Validator.html#t:support_length_types/0","title":"Magik.Validator.support_length_types/0","type":"type"},{"doc":"MagikMagik brings magics to your project that helps to make your life easierDocument here","ref":"readme.html","title":"Magik","type":"extras"},{"doc":"1. Magik.PaginatorHelp you to query by page and size with support for both counting and no counting total page (simple load more function)2. Magik.JsonViewRender json with custom field and relationship that helps you to reuse view and build consistent json structure3. Magik.ExcelViewHelp you to render excel data with format supported4. Magik.EctoEnumBuild enum module faster, shorter and can use directly in schema definition5. Magik.PowerUpRepoAdd some handy method to your Repo module that make your Repo module more powerful6. Magik.TelegramNotiProvide helper function watch exception, format message and send notification to a Telegram conversation7. Magik.ParamsProvide helper function to process params like scrub_params and clean_nil and cast params with given schema8. Magik.ContractProvide helper function to validate data structure and value, it does not cast value, only validate data9. Magik.SchemaInstruction to define schema that used with Magik.Params.cast/2 and Magik.Contract.validate/2","ref":"readme.html#here-are-some-magics-in-the-magik-toolbox","title":"Magik - Here are some magics in the Magik toolbox","type":"extras"}]