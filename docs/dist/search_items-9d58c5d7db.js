searchNodes=[{"doc":"Documentation for Magik.","ref":"Magik.html","title":"Magik","type":"module"},{"doc":"Hello world.Examplesiex&gt; Magik.hello() :world","ref":"Magik.html#hello/0","title":"Magik.hello/0","type":"function"},{"doc":"EctoEnum helps to generate enum type and enum helper function.You can define an enum module manually like thisdefmodule MyEnum do def enum, do: [&quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;] def value1, do: &quot;value1&quot; def value2, do: &quot;value2&quot; def value3, do: &quot;value3&quot; endNow with EctoEnum you can do it with a few lines of codedefmodule MyEnum do use Magik.EctoEnum, [&quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;] endIt still provides same functions with manual implemented moduleUse in ecto schemaEctoEnum also defines a Type module that you can used directly in Ecto schemadefmodule Order do schema &quot;orders do field :first_name, :string field :last_name, :string field :status, MyEnum.Type end endEctoEnum automatically validate value and only allow valid value","ref":"Magik.EctoEnum.html","title":"Magik.EctoEnum","type":"module"},{"doc":"","ref":"Magik.ExcelView.html","title":"Magik.ExcelView","type":"module"},{"doc":"render cell with a view, view must define render_cell/2 for each field field definition format:{field_name, format}field_name","ref":"Magik.ExcelView.html#render_cell/3","title":"Magik.ExcelView.render_cell/3","type":"function"},{"doc":"","ref":"Magik.ExcelView.html#render_row/3","title":"Magik.ExcelView.render_row/3","type":"function"},{"doc":"Provides functions to format value to string","ref":"Magik.Formatter.html","title":"Magik.Formatter","type":"module"},{"doc":"Format currency value to thousand separated stringParametersnumber: integer numberopts: list of format optionsthousand_separator: thousand separator character. Default is ,currency: currency character. Default is &quot;Ä‘&quot;Exampleiex&gt; Magik.Formatter.format_currency(&quot;1232321&quot;, thousand_separator: &quot;.&quot;, currency: &quot;$&quot;) 1.232.321$","ref":"Magik.Formatter.html#format_currency/2","title":"Magik.Formatter.format_currency/2","type":"function"},{"doc":"Format number to thousand seperated stringParametersnumber: integer numberseparator: thousand separator character. Default is .Exampleiex&gt; Magik.Formatter.format_thousand(&quot;1232321&quot;, &quot;.&quot;) 1.232.321","ref":"Magik.Formatter.html#format_thousand/2","title":"Magik.Formatter.format_thousand/2","type":"function"},{"doc":"Render a struct to a map with given optionsfields: which fields are extract directly from structcustom_fields: which fields are render using custom render_field/2 functionrelationships: a list of {field, view_module} defines which fields are rendered using another viewHere is a sample viewdefmodule MyApp.PostView do use JsonView @fields [:title, :content, :excerpt, :cover] @custom_fields [:like_count] @relationships [author: MyApp.AuthorView] def render(&quot;post.json&quot;, %{post: post}) do # 1st way if `use JsonView` render_json(post, @fields, @custom_fields, @relationships) # 2nd way same as above JsonView.render_json(post, __MODULE__, fields: @fields, custom_fields: @custom_fields, relationships: @relationships ) # 3rd render manual post |&gt; JsonView.render_fields(@fields) |&gt; Map.merge(JsonView.render_custom_fields(post, __MODULE__, @custom_fields)) |&gt; Map.merge(JsonView.render_relationships(post, @relationships)) end def render_field(:like_count, item) do # load like_count from some where end end","ref":"Magik.JsonView.html","title":"Magik.JsonView","type":"module"},{"doc":"Render field with custom render function View module must defines render_field/2 function to render each custom fielduse JsonView def render_field(:is_success, item) do item.state &gt; 3 end render_custom_fields(struct, __MODULE__, [:is_success])","ref":"Magik.JsonView.html#render_custom_fields/3","title":"Magik.JsonView.render_custom_fields/3","type":"function"},{"doc":"","ref":"Magik.JsonView.html#render_fields/2","title":"Magik.JsonView.render_fields/2","type":"function"},{"doc":"","ref":"Magik.JsonView.html#render_json/3","title":"Magik.JsonView.render_json/3","type":"function"},{"doc":"","ref":"Magik.JsonView.html#render_relationship/3","title":"Magik.JsonView.render_relationship/3","type":"function"},{"doc":"Render relationship field for struct. relationships is a list of {field, view} for mapping render. For each field, call function View.render() to render json for relation object.Example relationships:relationships = [comments: CommentView, author: UserView]Result of render_relationships(post, relationships) equal to output of below code%{ comments: CommentView.render_many(comments, CommentView, &quot;comment.json&quot;), autho: UserView.render_one(author, UserView, &quot;user.json&quot;) }","ref":"Magik.JsonView.html#render_relationships/2","title":"Magik.JsonView.render_relationships/2","type":"function"},{"doc":"","ref":"Magik.JsonView.html#render_template/3","title":"Magik.JsonView.render_template/3","type":"function"},{"doc":"Support light paginate the query. does not support counting total item because counting on large table is expensive update: count total if needed","ref":"Magik.Paginator.html","title":"Magik.Paginator","type":"module"},{"doc":"","ref":"Magik.Paginator.html#paginate/3","title":"Magik.Paginator.paginate/3","type":"function"},{"doc":"","ref":"Magik.PowerUpRepo.html","title":"Magik.PowerUpRepo","type":"module"},{"doc":"MagikTODO: Add description","ref":"readme.html","title":"Magik","type":"extras"},{"doc":"If available in Hex, the package can be installed by adding magik to your list of dependencies in mix.exs:def deps do [ {:magik, &quot;~&gt; 0.1.0&quot;} ] endDocumentation can be generated with ExDoc and published on HexDocs. Once published, the docs can be found at https://hexdocs.pm/magik.","ref":"readme.html#installation","title":"Magik - Installation","type":"extras"}]